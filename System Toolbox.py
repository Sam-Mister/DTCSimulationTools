# -*- coding: utf-8 -*-
"""
Created on Thu Jan 11 11:01:54 2024

@author: Sam Mister
"""
import qutip as qu
import numpy as np
import decimal as de
#The primary bit of information needed for the construction of this model is the 
#number of spins in the system.

#Now this following function can be called to generate the pauli spin operators 

def PauliN(N): #define SigmaX and SigmaZ for N spin system
    Sx = [qu.tensor([qu.sigmax() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    Sz = [qu.tensor([qu.sigmaz() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    Sy = [qu.tensor([qu.sigmay() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    return Sx, Sz, Sy

# Next the disordered parameters are needed to build the hamiltonian

def disorderGen(Jmean,Jvar,hmean,hvar,N): # Generates the unifrom distributions for sampling the parameters
    Jarr = [Jmean + np.random.uniform(-Jvar/2,Jvar/2) for i in range(N-1)]
    harr =[hmean + np.random.uniform(-hvar/2,hvar/2) for i in range(N)]  #[np.pi for i in range(N)] 
    return Jarr, harr 

#The system Hamiltonions can now be generated
#This also includes the option to add an external field.  
def HamiltonianGenerator(Jarr, harr, ExternalFieldStength, Sx, Sz): #Constructs the system Hamiltonions 
    
    N = len(Sx)

    HzTerm1 = qu.Qobj()
    for i in range(N):
        HzTerm1 += 0.5*harr[i]*Sz[i]
    
    HzTerm2 = qu.Qobj()
    HxTerm1 =  qu.Qobj()
    for i in range(N-1):
        HzTerm2 += ExternalFieldStength*(Sz[i]*Sz[i+1])
        HxTerm1 += Jarr[i]*(Sx[i]*Sx[i+1])#
    
    Hz = HzTerm1 + HzTerm2
    Hx = HxTerm1 + HzTerm2

    return Hz,Hx 


'''
Given a Hamiltonian and a coupling operator you can construct the 
lindblad operators accosiated with a global master equation assuming that the bath is 
in a thermal state with a given inverse temperature
s, G and B are all parameters of the external bath
'''

def J(B,en,s): #This function calculates spectral density function s = 1, ohmic and s > 1, super-ohmic
    eta = 1 #These are fixed properties of the bath spectral density 
    w_C = 1     
    return eta*(w_C**(1-s))*(en**(s))*np.exp(-en/w_C)

def L(eigstate1,eigstate2,energy,s,G,B,Bathcoupling): # This function calculates a specific L collapse operator
     v = abs((eigstate1.dag() * Bathcoupling * eigstate2).tr())# Calculates relevant matrix elements
     if abs(energy) == 0: # Special case to deal with the zero energy limit
         if s ==1: #for ohmic baths this is the zero energy density of states
             gamma = (G**2)/B
         elif s > 1:
             gamma = 0
     else:
         TempStep = (np.heaviside(energy,0)+ np.exp(-B*abs(energy))*np.heaviside(-energy,1))
         gamma = ((G**2*J(B,abs(energy),1))/float(1-de.Decimal(-B*abs(energy)).exp()))*TempStep
     return v*np.sqrt(gamma)*(eigstate1*eigstate2.dag())
 
'''
The above function takes two states given states and returns a jump operator 
with a temperature dependent rate. These states need to be generated by
diagonalising a system Hamiltonian. 
'''   
def GeneralGlobalME(Hx,Hz,s,G,B,V): #Calculates all the lindblad operators for the Global ME
    HxEigensystem  = Hx.eigenstates() #Calculate Eigensystem for Hx
    HxEVals = HxEigensystem[0] 
    HxEVects =  HxEigensystem[1]
     
    HzEigensystem  = Hz.eigenstates() #Calculate Eigensystem for Hz
    HzEVals = HzEigensystem[0] 
    HzEVects =  HzEigensystem[1]
    
    LXarr = []
    LZarr = []
    ZeroComparison = [[0+0j for n in range(2**NumSpins)] for n in range(2**NumSpins)]
    for m in range(len(HxEVects)):
        for n in range(len(HxEVects)):
            Lop= L(HxEVects[n],HxEVects[m],HxEVals[m]-HxEVals[n],s,G,B,V)
            if Lop.full().tolist() != ZeroComparison: #If the operator is = 0 don't include it 
                LXarr.append(Lop)
                
    for m in range(len(HzEVects)):
        for n in range(len(HzEVects)):
            Lop= L(HzEVects[n],HzEVects[m],HzEVals[m]-HzEVals[n],s,G,B,V)
            if Lop.full().tolist() != ZeroComparison:
                LZarr.append(Lop)
    return LXarr,LZarr