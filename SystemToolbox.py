# -*- coding: utf-8 -*-
"""
Created on Thu Jan 11 11:01:54 2024

@author: Sam Mister
"""
import qutip as qu
import numpy as np
import decimal as de
#The primary bit of information needed for the construction of this model is the 
#number of spins in the system.

#Now this following function can be called to generate the pauli spin operators 

def PauliN(N): #define SigmaX and SigmaZ for N spin system
    Sx = [qu.tensor([qu.sigmax() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    Sz = [qu.tensor([qu.sigmaz() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    Sy = [qu.tensor([qu.sigmay() if m == n else qu.identity(2) for n in range(N)]) for m in range(N)]
    return Sx, Sz, Sy

# Next the disordered parameters are needed to build the hamiltonian
np.random.seed(42)
def disorderGen(Jmean,Jvar,hmean,hvar,N): # Generates the unifrom distributions for sampling the parameters
    Jarr = [Jmean + np.random.uniform(-Jvar/2,Jvar/2) for i in range(N-1)]
    harr =[hmean + np.random.uniform(-hvar/2,hvar/2) for i in range(N)]  #[np.pi for i in range(N)] 
    return Jarr, harr 

#The system Hamiltonions can now be generated
#This also includes the option to add an external field.  
def HamiltonianGenerator(Jarr, harr, ExternalFieldStength, Sx, Sz): #Constructs the system Hamiltonions 
    
    N = len(Sx)

    HzTerm1 = qu.Qobj()
    for i in range(N):
        HzTerm1 += 0.5*harr[i]*Sz[i]
    
    HzTerm2 = qu.Qobj()
    HxTerm1 =  qu.Qobj()
    for i in range(N-1):
        HzTerm2 += ExternalFieldStength*(Sz[i]*Sz[i+1])
        HxTerm1 += Jarr[i]*(Sx[i]*Sx[i+1])#
    
    Hz = HzTerm1 + HzTerm2
    Hx = HxTerm1 + HzTerm2

    return Hz,Hx 


'''
Given a Hamiltonian and a coupling operator you can construct the 
lindblad operators accosiated with a global master equation assuming that the bath is 
in a thermal state with a given inverse temperature
s, G and B are all parameters of the external bath
'''

def J(B,en,s): #This function calculates spectral density function s = 1, ohmic and s > 1, super-ohmic
    eta = 1 #These are fixed properties of the bath spectral density 
    w_C = 1     
    return eta*(w_C**(1-s))*(en**(s))*np.exp(-en/w_C)

def L(eigstate1,eigstate2,energy,s,G,B,Bathcoupling): # This function calculates a specific L collapse operator
     v = abs((eigstate1.dag() * Bathcoupling * eigstate2).tr())# Calculates relevant matrix elements
     if abs(energy) == 0: # Special case to deal with the zero energy limit
         if s ==1: #for ohmic baths this is the zero energy density of states
             gamma = (G**2)/B
         elif s > 1:
             gamma = 0
     else:
         TempStep = (np.heaviside(energy,0)+ np.exp(-B*abs(energy))*np.heaviside(-energy,1))
         gamma = ((G**2*J(B,abs(energy),1))/float(1-de.Decimal(-B*abs(energy)).exp()))*TempStep
     return v*np.sqrt(gamma)*(eigstate1*eigstate2.dag())
 
'''
The above function takes two states given states and returns a jump operator 
with a temperature dependent rate. These states need to be generated by
diagonalising a system Hamiltonian. This function leaves the bathcoupling unspecified 
meaning operators for different enviroment coupling schemes can be used 
'''   
def GeneralGlobalME(Hx,Hz,s,G,B,Bathcoupling): #Calculates all the lindblad operators for the Global ME
    NumSpins = len(Hx.dims[0])  
    HxEigensystem  = Hx.eigenstates() #Calculate Eigensystem for Hx
    HxEVals = HxEigensystem[0] 
    HxEVects =  HxEigensystem[1]
     
    HzEigensystem  = Hz.eigenstates() #Calculate Eigensystem for Hz
    HzEVals = HzEigensystem[0] 
    HzEVects =  HzEigensystem[1]
    
    LXarr = []
    LZarr = []
    
    '''
    Now loop over all possible pair of eigenvalues for each hamiltonian 
    I also check to see if any operators are = 0 to save storing them.
    '''
    ZeroComparison = [[0+0j for n in range(2**NumSpins)] for n in range(2**NumSpins)]
    
    for m in range(len(HxEVects)):
        for n in range(len(HxEVects)):
            Lop= L(HxEVects[n],HxEVects[m],HxEVals[m]-HxEVals[n],s,G,B,Bathcoupling)
            if Lop.full().tolist() != ZeroComparison: #If the operator is = 0 don't include it 
                LXarr.append(Lop)
                
    for m in range(len(HzEVects)):
        for n in range(len(HzEVects)):
            Lop= L(HzEVects[n],HzEVects[m],HzEVals[m]-HzEVals[n],s,G,B,Bathcoupling)
            if Lop.full().tolist() != ZeroComparison:
                LZarr.append(Lop)
                
    return LXarr,LZarr

'''
We can also construct local master equations for a fully connected model and 
for a boundary driven model. 
'''

def LocalME(n,G,Sx,Sy): # here n represents the thermal occupation number 
    l = []
    for i in range(len(Sx)):
        l.append(G*(n+1)*(Sx[i] - 1j*Sy[i]))
        l.append(G*n*(Sx[i] + 1j*Sy[i]))
    return l,l,l

def BoundaryDriveLocalME(n1,n2,G,Sx,Sy):# n1 and n2 are different thermal occupation numbers. 
    
    l = []
    l.append(G*(n1+1)*(Sx[0] - 1j*Sy[0]))
    l.append(G*n1*(Sx[0] + 1j*Sy[0]))
    l.append(G*(n2+1)*(Sx[-1] - 1j*Sy[-1]))
    l.append(G*n2*(Sx[-1] + 1j*Sy[-1]))
    return l,l,l